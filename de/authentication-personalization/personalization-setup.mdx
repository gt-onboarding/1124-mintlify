---
title: "Einrichtung der Personalisierung"
description: "Ermöglichen Sie Nutzern die Anmeldung für personalisierte Dokumentationserlebnisse"
icon: "user-cog"
---

Die Personalisierung passt Ihre Dokumentation für jede:n angemeldete:n Nutzer:in an. Sie können beispielsweise ihre API-keys automatisch ausfüllen, Inhalte anzeigen, die speziell auf ihren Plan oder ihre Rolle zugeschnitten sind, oder Abschnitte ausblenden, die für sie nicht relevant sind.

<div id="personalization-features">
  ## Personalisierungsfunktionen
</div>

Passen Sie Inhalte mit diesen Personalisierungsoptionen an.

<div id="api-key-prefilling">
  ### Automatisches Ausfüllen von API-Keys
</div>

Füllen Sie Felder im API Playground automatisch mit nutzerspezifischen Werten aus, indem Sie in Ihren Benutzerdaten entsprechende Feldnamen bereitstellen. Die Feldnamen in Ihren Benutzerdaten müssen exakt den Namen im API Playground entsprechen, damit das automatische Ausfüllen funktioniert.

<div id="dynamic-mdx-content">
  ### Dynamische MDX-Inhalte
</div>

Zeigen Sie dynamische Inhalte basierend auf Benutzerinformationen wie Name, Tarif oder Organisation mit der Variable `user` an.

```jsx
Willkommen zurück, {user.firstName}! Ihr {user.org?.plan}-Tarif umfasst...
```

Siehe den Abschnitt [User data format](#user-data-format) weiter unten für detaillierte Beispiele und Hinweise zur Implementierung.


<div id="page-visibility">
  ### Seiten­sichtbarkeit
</div>

Beschränken Sie, welche Seiten für Ihre Nutzer sichtbar sind, indem Sie `groups`-Felder zum Frontmatter Ihrer Seiten hinzufügen. Standardmäßig ist jede Seite für jeden Nutzer sichtbar.

Nutzer sehen nur Seiten für `groups`, denen sie angehören.

```mdx
---
title: "Verwaltung Ihrer Benutzer"
description: "Hinzufügen und Entfernen von Benutzern aus Ihrer Organisation"
groups: ["admin"]
---
```


<div id="user-data-format">
  ## Format der Benutzerdaten
</div>

Bei der Implementierung von Personalisierung gibt Ihr System Benutzerdaten in einem bestimmten Format zurück, das die Anpassung von Inhalten ermöglicht. Diese Daten können je nach Handshake-Methode entweder als JSON-Objekt im Rohformat oder in einem signierten JWT gesendet werden. Die Struktur der Daten ist in beiden Fällen identisch.

```tsx
type User = {
  expiresAt?: number;
  groups?: string[];
  content?: Record<string, any>;
  apiPlaygroundInputs?: {
    header?: Record<string, any>;
    query?: Record<string, any>;
    cookie?: Record<string, any>;
    server?: Record<string, string>;
  };
};
```

<ParamField path="expiresAt" type="number">
  Ablaufzeit der Sitzung in **Sekunden seit der Unix-Epoche**. Wenn der Benutzer nach diesem Zeitpunkt eine Seite lädt, werden seine gespeicherten Daten automatisch gelöscht und er muss sich erneut authentifizieren.
  <Warning><b>Für JWT-Handshakes:</b> Dies unterscheidet sich vom `exp`-Claim des JWT, der festlegt, wann ein JWT als ungültig gilt. Setzen Sie den `exp`-Claim des JWT aus Sicherheitsgründen auf eine kurze Dauer (10 Sekunden oder weniger). Verwenden Sie `expiresAt` für die tatsächliche Sitzungsdauer (von Stunden bis Wochen).</Warning>
</ParamField>

<ParamField path="groups" type="string[]">
  Liste der Gruppen, denen der Benutzer angehört. Seiten mit passenden `groups` in ihrem Frontmatter sind für diesen Benutzer sichtbar.

  **Beispiel**: Ein Benutzer mit `groups: ["admin", "engineering"]` kann auf Seiten zugreifen, die entweder mit der Gruppe `admin` oder `engineering` gekennzeichnet sind.
</ParamField>

<ParamField path="content" type="object">
  Benutzerdefinierte Daten, die in Ihrem `MDX`-Inhalt über die Variable `user` verfügbar sind. Verwenden Sie dies für dynamische Personalisierung in Ihrer gesamten Dokumentation.

  **Einfaches Beispiel**:

  ```json
  { "firstName": "Ronan", "company": "Acme Corp", "plan": "Enterprise" }
  ```

  **Verwendung in `MDX`**:

  ```mdx
  Welcome back, {user.firstName}! Your {user.plan} plan includes...
  ```

  Mit den Beispiel-`user`-Daten würde dies wie folgt gerendert: Welcome back, Ronan! Your Enterprise plan includes...

  **Erweitertes, bedingtes Rendering**:

  ```jsx
  Authentication is an enterprise feature. {
    user.org === undefined
      ? <>To access this feature, first create an account at the <a href="https://dashboard.mintlify.com/login">Mintlify dashboard</a>.</>
      : user.org.plan !== 'enterprise'
        ? <>You are currently on the ${user.org.plan ?? 'free'} plan. See <a href="https://mintlify.com/pricing">our pricing page</a> for information about upgrading.</>
        : <>To request this feature for your enterprise org, contact your admin.</>
  }
  ```

  <Note>
    Die Informationen in `user` sind nur für angemeldete Benutzer verfügbar. Für abgemeldete Benutzer ist der Wert von `user` `{}`. Um zu verhindern, dass die Seite bei abgemeldeten Benutzern abstürzt, verwenden Sie für Ihre `user`-Felder stets Optional Chaining, z. B. `{user.org?.plan}`.
  </Note>
</ParamField>

<ParamField path="apiPlaygroundInputs" type="object">
  Benutzerspezifische Werte, die Felder im API Playground vorausfüllen. Spart Zeit, indem beim Testen von APIs die eigenen Daten automatisch eingetragen werden.

  **Beispiel**:

  ```json
  {
    "header": { "X-API-Key": "user_api_key_123" },
    "server": { "subdomain": "foo" },
    "query": { "org_id": "12345" }
  }
  ```

  Wenn ein Benutzer Anfragen über eine bestimmte Subdomain stellt, können Sie `{ server: { subdomain: 'foo' } }` als `apiPlaygroundInputs`-Feld senden. Dieser Wert wird auf jeder API-Seite mit dem `subdomain`-Feld vorausgefüllt.

  <Note>Die Felder `header`, `query` und `cookie` werden nur vorausgefüllt, wenn sie Teil Ihres [OpenAPI-Sicherheitsschemas](https://swagger.io/docs/specification/authentication/) sind. Befindet sich ein Feld im Abschnitt `Authorization` oder `Server`, wird es vorausgefüllt. Das Erstellen eines Standard-Header-Parameters mit dem Namen `Authorization` aktiviert diese Funktion nicht.</Note>
</ParamField>


<div id="example-user-data">
  ### Beispielbenutzerdaten
</div>

```json
{
  "expiresAt": 1735689600,
  "groups": ["admin", "beta-users"],
  "content": {
    "firstName": "Jane",
    "lastName": "Smith",
    "company": "TechCorp",
    "plan": "Enterprise",
    "region": "us-west"
  },
  "apiPlaygroundInputs": {
    "header": {
      "Authorization": "Bearer abc123",
      "X-Org-ID": "techcorp"
    },
    "server": {
      "environment": "production",
      "region": "us-west"
    }
  }
}
```


<div id="configuring-personalization">
  ## Personalisierung konfigurieren
</div>

Wählen Sie die Handshake-Methode aus, die Sie konfigurieren möchten.

<Tabs>
  <Tab title="JWT (JSON Web Token)">
    ### Voraussetzungen

    * Ein Login-System, das JWTs generieren und signieren kann
    * Ein Backend-Service, der Redirect-URLs erstellen kann

    ### Implementierung

    <Steps>
      <Step title="Generate a private key.">
        1. Gehe in deinem Dashboard zu [Authentication](https://dashboard.mintlify.com/settings/deployment/authentication).
        2. Wähle **Personalization**.
        3. Wähle **JWT**.
        4. Gib die URL deines bestehenden Login-Flows ein und wähle **Änderungen speichern**.
        5. Wähle **Generate new key**.
        6. Speichere deinen key sicher, sodass dein Backend darauf zugreifen kann.
      </Step>

      <Step title="Integrate Mintlify personalization into your login flow.">
        Passe deinen bestehenden Login-Flow an und füge nach dem Login diese Schritte hinzu:

        * Erstelle ein JWT, das die Info des angemeldeten Benutzers im `User`-Format enthält. Siehe oben den Abschnitt [User data format](#user-data-format) für weitere Informationen.
        * Signiere das JWT mit dem geheimen key mittels des ES256-Algorithmus.
        * Erstelle eine Redirect-URL zurück zu deinen Docs und füge das JWT als hash hinzu.
      </Step>
    </Steps>

    ### Beispiel

    Deine Dokumentation wird unter `docs.foo.com` gehostet. Du möchtest, dass deine Docs von deinem Dashboard getrennt sind (oder du hast kein Dashboard) und die Personalisierung aktivieren.

    Generiere ein JWT-Secret. Erstelle dann einen Login-Endpoint unter `https://foo.com/docs-login`, der einen Login-Flow zu deiner Dokumentation startet.

    Nach der Überprüfung der Benutzeranmeldedaten:

    * Generiere ein JWT mit Benutzerdaten im Mintlify-Format.
    * Signiere das JWT und leite weiter zu `https://docs.foo.com#{SIGNED_JWT}`.

    ```ts
    import * as jose from 'jose';
    import { Request, Response } from 'express';

    const TWO_WEEKS_IN_MS = 1000 * 60 * 60 * 24 * 7 * 2;

    const signingKey = await jose.importPKCS8(process.env.MINTLIFY_PRIVATE_KEY, 'ES256');

    export async function handleRequest(req: Request, res: Response) {
      const user = {
        expiresAt: Math.floor((Date.now() + TWO_WEEKS_IN_MS) / 1000),
        groups: res.locals.user.groups,
        content: {
          firstName: res.locals.user.firstName,
          lastName: res.locals.user.lastName,
        },
      };

      const jwt = await new jose.SignJWT(user)
        .setProtectedHeader({ alg: 'ES256' })
        .setExpirationTime('10 s')
        .sign(signingKey);

      return res.redirect(`https://docs.foo.com#${jwt}`);
    }
    ```

    ### Seitenanker beibehalten

    Um Nutzer nach dem Login zu bestimmten Abschnitten weiterzuleiten, verwenden Sie dieses URL-Format: `https://docs.foo.com/page#jwt={SIGNED_JWT}&anchor={ANCHOR}`.

    **Beispiel**:

    * Ursprüngliche URL: `https://docs.foo.com/quickstart#step-one`
    * Weiterleitungs-URL: `https://docs.foo.com/quickstart#jwt={SIGNED_JWT}&anchor=step-one`
  </Tab>

  <Tab title="OAuth 2.0">
    ### Voraussetzungen

    * Ein OAuth-Server, der den Authorization Code Flow mit PKCE unterstützt
    * Möglichkeit, einen API-Endpoint zu erstellen, der mit OAuth-Access-Tokens erreichbar ist

    ### Implementierung

    <Steps>
      <Step title="User-Info-API-Endpoint erstellen.">
        Erstellen Sie einen API-Endpoint, der:

        * OAuth-Access-Tokens zur Authentifizierung akzeptiert.
        * Benutzerdaten im `User`-Format zurückgibt. Weitere Informationen finden Sie im Abschnitt [User-Datenformat](#user-data-format) oben.
        * Die Scopes für den Zugriff definiert.
      </Step>

      <Step title="OAuth-Personalisierungseinstellungen konfigurieren.">
        1. Gehen Sie in Ihrem Dashboard zu [Authentication](https://dashboard.mintlify.com/settings/deployment/authentication).
        2. Wählen Sie **Personalization**.
        3. Wählen Sie **OAuth** und konfigurieren Sie diese Felder:

        * **Authorization URL**: Ihr OAuth-Authorization-Endpoint.
        * **Client ID**: Ihr OAuth 2.0-Client-Identifier.
        * **Scopes**: Anzufordernde Berechtigungen. Kopieren Sie die **gesamte** Scope-Zeichenfolge (zum Beispiel bei einem Scope wie `provider.users.docs` den vollständigen `provider.users.docs`). Muss mit den Scopes des Endpoints übereinstimmen, den Sie im ersten Schritt konfiguriert haben.
        * **Token URL**: Ihr OAuth-Token-Exchange-Endpoint.
        * **Info API URL**: Endpoint zum Abrufen von Benutzerdaten für die Personalisierung. Im ersten Schritt erstellt.

        4. Wählen Sie **Änderungen speichern**
      </Step>

      <Step title="OAuth-Server konfigurieren.">
        1. Kopieren Sie die **Redirect URL** aus Ihren [authentication settings](https://dashboard.mintlify.com/settings/deployment/authentication).
        2. Fügen Sie diese URL als autorisierte Redirect-URL in Ihrer OAuth-Serverkonfiguration hinzu.
      </Step>
    </Steps>

    ### Beispiel

    Ihre Dokumentation wird unter `foo.com/docs` gehostet und Sie haben einen vorhandenen OAuth-Server, der den PKCE-Flow unterstützt. Sie möchten Ihre Dokumentation basierend auf Benutzerdaten personalisieren.

    **Erstellen Sie einen User-Info-Endpoint** unter `api.foo.com/docs/user-info`, der ein OAuth-Access-Token mit dem Scope `provider.users.docs` erfordert und mit den benutzerdefinierten Daten des Nutzers antwortet:

    ```json
    {
      "content": {
        "firstName": "Jane",
        "lastName": "Doe"
      },
      "groups": ["engineering", "admin"]
    }
    ```

    **Konfigurieren Sie die Details Ihres OAuth-Servers** in Ihrem Dashboard:

    * **Authorization URL**: `https://auth.foo.com/authorization`
    * **Client ID**: `ydybo4SD8PR73vzWWd6S0ObH`
    * **Scopes**: `['docs-user-info']`
    * **Token URL**: `https://auth.foo.com/exchange`
    * **Info API URL**: `https://api.foo.com/docs/user-info`

    **Konfigurieren Sie Ihren OAuth-Server**, damit Weiterleitungen zu Ihrer Callback-URL zulässig sind.
  </Tab>

  <Tab title="Geteilte Sitzung">
    ### Voraussetzungen

    * Ein Dashboard oder Benutzerportal mit cookiebasierter Sitzungs-Authentifizierung.
    * Möglichkeit, einen API-Endpoint am selben Origin oder auf derselben Subdomain wie Ihr Dashboard zu erstellen.
      * Wenn Ihr Dashboard unter `foo.com` erreichbar ist, muss die **API URL** mit `foo.com` oder `*.foo.com` beginnen.
      * Wenn Ihr Dashboard unter `dash.foo.com` erreichbar ist, muss die **API URL** mit `dash.foo.com` oder `*.dash.foo.com` beginnen.
    * Ihre Docs werden unter derselben Domain oder Subdomain wie Ihr Dashboard gehostet.
      * Wenn Ihr Dashboard unter `foo.com` erreichbar ist, müssen Ihre **Docs** unter `foo.com` oder `*.foo.com` gehostet werden.
      * Wenn Ihr Dashboard unter `*.foo.com` erreichbar ist, müssen Ihre **Docs** unter `foo.com` oder `*.foo.com` gehostet werden.

    ### Implementierung

    <Steps>
      <Step title="Create user info API endpoint.">
        Erstellen Sie einen API-Endpoint, der:

        * Ihre bestehende Sitzungs-Authentifizierung verwendet, um Benutzer zu identifizieren
        * Benutzerdaten im Format `User` zurückgibt (siehe den Abschnitt [User data format](#user-data-format) oben)
        * Falls die API-Domain und die Docs-Domain **nicht exakt übereinstimmen**:

          * Fügen Sie die Docs-Domain zum `Access-Control-Allow-Origin`-Header Ihrer API hinzu (darf nicht `*` sein).
          * Setzen Sie den `Access-Control-Allow-Credentials`-Header Ihrer API auf `true`.

          <Warning>
            Aktivieren Sie CORS-Header nur für diesen spezifischen Endpoint, nicht für Ihre gesamte Dashboard-API.
          </Warning>
      </Step>

      <Step title="Configure your personalization settings">
        1. Gehen Sie in Ihrem Dashboard zu [Authentication](https://dashboard.mintlify.com/settings/deployment/authentication).
        2. Wählen Sie **Personalization**.
        3. Wählen Sie **Shared Session**.
        4. Geben Sie Ihre **Info API URL** ein, also den Endpoint aus dem ersten Schritt.
        5. Geben Sie Ihre **Login URL** ein, über die sich Benutzer in Ihr Dashboard anmelden.
        6. Wählen Sie **Änderungen speichern**.
      </Step>
    </Steps>

    ### Beispiele

    #### Dashboard auf Subdomain, Docs auf Subdomain

    Sie haben ein Dashboard unter `dash.foo.com`, das cookiebasierte Sitzungs-Authentifizierung verwendet. Ihre Dashboard-API-Routen werden unter `dash.foo.com/api` gehostet. Sie möchten die Personalisierung für Ihre unter `docs.foo.com` gehosteten Docs einrichten.

    **Einrichtungsprozess**:

    1. **Endpoint erstellen** `dash.foo.com/api/docs/user-info`, der Benutzer über Sitzungs-Authentifizierung identifiziert und deren Benutzerdaten zurückgibt.
    2. **CORS-Header hinzufügen** nur für diese Route:
       * `Access-Control-Allow-Origin`: `https://docs.foo.com`
       * `Access-Control-Allow-Credentials`: `true`
    3. **API URL konfigurieren** in den Authentifizierungseinstellungen: `https://dash.foo.com/api/docs/user-info`.

    #### Dashboard auf Subdomain, Docs auf Root

    Sie haben ein Dashboard unter `dash.foo.com`, das cookiebasierte Sitzungs-Authentifizierung verwendet. Ihre Dashboard-API-Routen werden unter `dash.foo.com/api` gehostet. Sie möchten die Personalisierung für Ihre unter `foo.com/docs` gehosteten Docs einrichten.

    **Einrichtungsprozess**:

    1. **Endpoint erstellen** `dash.foo.com/api/docs/user-info`, der Benutzer über Sitzungs-Authentifizierung identifiziert und deren Benutzerdaten zurückgibt.
    2. **CORS-Header hinzufügen** nur für diese Route:
       * `Access-Control-Allow-Origin`: `https://foo.com`
       * `Access-Control-Allow-Credentials`: `true`
    3. **API URL konfigurieren** in den Authentifizierungseinstellungen: `https://dash.foo.com/api/docs/user-info`.

    #### Dashboard auf Root, Docs auf Root

    Sie haben ein Dashboard unter `foo.com/dashboard`, das cookiebasierte Sitzungs-Authentifizierung verwendet. Ihre Dashboard-API-Routen werden unter `foo.com/api` gehostet. Sie möchten die Personalisierung für Ihre unter `foo.com/docs` gehosteten Docs einrichten.

    **Einrichtungsprozess**:

    1. **Endpoint erstellen** `foo.com/api/docs/user-info`, der Benutzer über Sitzungs-Authentifizierung identifiziert und deren Benutzerdaten zurückgibt.
    2. **API URL konfigurieren** in den Authentifizierungseinstellungen: `https://foo.com/api/docs/user-info`

    <Note>
      Es ist keine CORS-Konfiguration erforderlich, da Dashboard und Docs dieselbe Domain verwenden.
    </Note>
  </Tab>
</Tabs>